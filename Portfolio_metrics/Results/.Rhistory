sharpes_pca1<-cor(data_pca2$Sharpes, data_pca2$pc1, method= "spearman")
sharpes_pca2<-cor(data_pca2$Sharpes, data_pca2$pc2, method= "spearman")
sharpes_pca3<-cor(data_pca2$Sharpes, data_pca2$pc3, method= "spearman")
digits=2
labels<-c( "PC1", "PC2","PC3")
results1<-c(CV_pca1, CV_pca2,CV_pca3)
results2<-c(sharpes_pca1, sharpes_pca2, sharpes_pca3)
results3<-cbind(labels, results1, results2)
out_table<-kable(results3, digits=getOption("digits"), col.names=c("Principal component","CV", "Sharpe's"))
out_table
plot(Sharpes~pc1, data=data_pca2, xlab=c("PC1"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc1, data=data_pca2, xlab=c("PC1"), ylab=c("CV"))
plot(Sharpes~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("CV"))
plot(Sharpes~pc3, data=data_pca2, xlab=c("PC3"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc3, data=data_pca2, xlab=c("PC3"), ylab=c("CV"))
sort(abs(pca_test2$rotation[,1]))
sort(abs(pca_test2$rotation[,2]))
sort(abs(pca_test2$rotation[,3]))
# create dataframe for looping regression and plots
OC_COHO_SharpeRatio_CV
data4_pop<-cbind(CohoDataSummary$Population, log(data2+1))
colnames(data4_pop)[1]<-"Population"
names(data4_pop)
names(OC_COHO_SharpeRatio_CV)
colnames(OC_COHO_SharpeRatio_CV)[2]<-"Sharps"
portfolio<-merge(data4_pop, OC_COHO_SharpeRatio_CV, by="Population")
# Create List for looping plots
vars <- names(data2)
# Create function for returning desired values from linear regression.
# This allows regression to be performed in loop
regresfun <- function(x) {
var <- eval(parse(text = paste("portfolio$",x)))
mod <- summary(lm(Sharps ~ var, data = portfolio))
results <- data.frame(
variable = x,
intercept = mod$coefficients[1,1],
beta = mod$coefficients[2,1],
p.val = mod$coefficients[2,4],
rsquare = mod$adj.r.squared,
rss = sum(mod$residuals^2))
return(results)
}
# Loop regression and save results in new object, lmresults
lmresults <- (lapply(vars, regresfun))
lmresults <- do.call("rbind", lmresults)
setwd("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/Results")
# Create plots with summary statistics and save
for (i in seq_along(vars)) {
plot1 <- ggplot() +
geom_point(data = portfolio, aes_string(x = vars[i], y = "Sharps")) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.95*max(portfolio$Sharps),
hjust = 0,
label = paste("beta =",round(filter(lmresults, variable == vars[i])$beta,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.9*max(portfolio$Sharps),
hjust = 0,
label = paste("p.val =",round(filter(lmresults, variable == vars[i])$p.val,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.85*max(portfolio$Sharps),
hjust = 0,
label = paste("rsquare =",round(filter(lmresults, variable == vars[i])$rsquare,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.8*max(portfolio$Sharps),
hjust = 0,
label = paste("rss =",round(filter(lmresults, variable == vars[i])$rss,3))) +
geom_abline(intercept = filter(lmresults, variable == vars[i])$intercept,
slope = filter(lmresults, variable == vars[i])$beta)
ggsave(filename = paste("Plots/Sharpes/", vars[i], ".png", sep = ""),
width = 6, height = 5, units = "in", dpi = 300)
print(plot1)
}
# create dataframe for looping regression and plots
OC_COHO_SharpeRatio_CV
data4_pop<-cbind(CohoDataSummary$Population, log(data2+1))
colnames(data4_pop)[1]<-"Population"
names(data4_pop)
names(OC_COHO_SharpeRatio_CV)
colnames(OC_COHO_SharpeRatio_CV)[2]<-"Sharps"
portfolio<-merge(data4_pop, OC_COHO_SharpeRatio_CV, by="Population")
# Create List for looping plots
vars <- names(data2)
# Create function for returning desired values from linear regression.
# This allows regression to be performed in loop
regresfun <- function(x) {
var <- eval(parse(text = paste("portfolio$",x)))
mod <- summary(lm(Sharps ~ var, data = portfolio))
results <- data.frame(
variable = x,
intercept = mod$coefficients[1,1],
beta = mod$coefficients[2,1],
p.val = mod$coefficients[2,4],
rsquare = mod$adj.r.squared,
rss = sum(mod$residuals^2))
return(results)
}
# Loop regression and save results in new object, lmresults
lmresults <- (lapply(vars, regresfun))
lmresults <- do.call("rbind", lmresults)
setwd("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/Results")
# Create plots with summary statistics and save
for (i in seq_along(vars)) {
plot1 <- ggplot() +
geom_point(data = portfolio, aes_string(x = vars[i], y = "Sharps")) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.95*max(portfolio$Sharps),
hjust = 0,
label = paste("beta =",round(filter(lmresults, variable == vars[i])$beta,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.9*max(portfolio$Sharps),
hjust = 0,
label = paste("p.val =",round(filter(lmresults, variable == vars[i])$p.val,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.85*max(portfolio$Sharps),
hjust = 0,
label = paste("rsquare =",round(filter(lmresults, variable == vars[i])$rsquare,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.8*max(portfolio$Sharps),
hjust = 0,
label = paste("rss =",round(filter(lmresults, variable == vars[i])$rss,3))) +
geom_abline(intercept = filter(lmresults, variable == vars[i])$intercept,
slope = filter(lmresults, variable == vars[i])$beta)
ggsave(filename = paste("Plots/Sharpes/", vars[i], ".png", sep = ""),
width = 6, height = 5, units = "in", dpi = 300)
print(plot1)
}
# create dataframe for looping regression and plots
OC_COHO_SharpeRatio_CV
data4_pop<-cbind(CohoDataSummary$Population, log(data2+1))
colnames(data4_pop)[1]<-"Population"
names(data4_pop)
names(OC_COHO_SharpeRatio_CV)
colnames(OC_COHO_SharpeRatio_CV)[2]<-"Sharps"
portfolio<-merge(data4_pop, OC_COHO_SharpeRatio_CV, by="Population")
# Create List for looping plots
vars <- names(data2)
# Create function for returning desired values from linear regression.
# This allows regression to be performed in loop
regresfun <- function(x) {
var <- eval(parse(text = paste("portfolio$",x)))
mod <- summary(lm(CV ~ var, data = portfolio))
results <- data.frame(
variable = x,
intercept = mod$coefficients[1,1],
beta = mod$coefficients[2,1],
p.val = mod$coefficients[2,4],
rsquare = mod$adj.r.squared,
rss = sum(mod$residuals^2))
return(results)
}
# Loop regression and save results in new object, lmresults
lmresults <- (lapply(vars, regresfun))
lmresults <- do.call("rbind", lmresults)
setwd("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/Results")
# Create plots with summary statistics and save
for (i in seq_along(vars)) {
plot2 <- ggplot() +
geom_point(data = portfolio, aes_string(x = vars[i], y = "CV")) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.95*max(portfolio$CV),
hjust = 0,
label = paste("beta =",round(filter(lmresults, variable == vars[i])$beta,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.9*max(portfolio$CV),
hjust = 0,
label = paste("p.val =",round(filter(lmresults, variable == vars[i])$p.val,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.85*max(portfolio$CV),
hjust = 0,
label = paste("rsquare =",round(filter(lmresults, variable == vars[i])$rsquare,3))) +
annotate("text",
x = min(eval(parse(text = paste("portfolio$", vars[i])))),
y = 0.8*max(portfolio$CV),
hjust = 0,
label = paste("rss =",round(filter(lmresults, variable == vars[i])$rss,3))) +
geom_abline(intercept = filter(lmresults, variable == vars[i])$intercept,
slope = filter(lmresults, variable == vars[i])$beta)
ggsave(filename = paste("Plots/CV/", vars[i], ".png", sep = ""),
width = 6, height = 5, units = "in", dpi = 300)
print(plot2)
}
names(data4_scale_pop_2)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(vegan)
library(BiodiversityR)
source('L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/R_code/biostats.R')
library(knitr)
library(dplyr)
library(reshape2)
library(ggplot2)
library(MASS)
OC_COHO_SharpeRatio_CV <- read_csv("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/OC_COHO_SharpeRatio_CV.csv")
CohoDataSummary <- read_csv("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Matt's Work/Data/Spreadsheets/CohoDataSummary.csv")
#summary(CohoDataSummary)
data1<-CohoDataSummary[,-1]
data2<-data1[,-1]
#names(data2)
#class(data2)
#pairs(data2)
cor_out<-cor(data2, method="spearman")
write.csv(cor_out, "L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/watershed_correlations.csv")
plot(data2$MeanAnnualPrecip_mm, data2$Latitude)
plot(data2$MeanAugtemps_c, data2$Latitude)
plot(data2$MeanAugtemps_c, data2$MeanAnnualPrecip_mm)
plot(data2$TotalLength_m, data2$HighIP_m)
# data3 <- select(data2, HighCritHab_p,
#                 MeanElev_m,
#                 MeanAnnualPrecip_mm,
#                 MeanBFI,
#                 Watershed_sqkm,
#                 Sedimentary_p,
#                 HighIP_p,
#                 Estuary_sqkm,
#                 Lake_p,
#                 MeanHFI,
#                 Latitude,
#                 SplashCount)
# create subset from spreadsheet
watershed_correlations_plus_selection <- read_csv("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/watershed_correlations_plus_selection.csv")
vars<-watershed_correlations_plus_selection[ which(watershed_correlations_plus_selection$Include=="Y"),]
vars2<-unique(vars$Attribute)
vars2
# data3<-select(data2,
#               MeanCanopy_p,
#               HighIP_m,
#               Sedimentary_p,
#               Estuary_sqkm,
#               Lake_sqkm,
#               Public_p,
#               Latitude,
#               Agric_p)
keep<-c(6, 13, 16, 18, 19, 24, 26, 28 )
data3<-data2[, keep ]
pairs(data3)
cor(data3, method="spearman")
data4<-log(data3+1)
#dim(data4)
data4<-log(data3+1)
#dim(data4)
data5<-cbind(CohoDataSummary$Population, data4)
#names(data5)
colnames(data5)[1]<-"ID"
uv.outliers(data5,id='ID', var='MeanCanopy_p:Agric_p', sd.limit=3)
uv.outliers(data4,id='MeanCanopy_p', var='MeanCanopy_p:Agric_p')
#univariate test indicate no outliers
mv.outliers(data5,var='MeanCanopy_p:Agric_p',method='bray')
# no outliers from multivariate analysis
# pca
pca_test<-prcomp(data4, scale=TRUE)
# look at signficance of eigen value compared to broken stick expected value by random
pca.eigenval(pca_test)
# test signifciance of eigen values a different way
#ordi.monte(data4,ord='pca',dim=3)
#ordi.scree(pca_test,ord='pca')
screeplot(pca_test)
# eigen vectors
pca.eigenvec(pca_test,dim=3,digits=3,cutoff=.2)
# structure coefficients
pca.structure(pca_test,data4,dim=3,cutoff=.2)
# variance accounted for in total by retained principal components by adding up all squared structure coefficients of retained principal components
pca.communality(pca_test,data4,dim=3)
biplot(pca_test)
# grab principal component scores for significant components
pc1<-pca_test$x[1:21,1]
pc2<-pca_test$x[1:21,2]
pc3<-pca_test$x[1:21,3]
#class(pc1)
data_pca<-cbind(CohoDataSummary$Population,data4,pc1, pc2, pc3)
colnames(data_pca)[1]<-"population"
#View(OC_COHO_SharpeRatio_CV)
data_pca2<-merge(OC_COHO_SharpeRatio_CV, data_pca, by.x="Population", by.y="population")
#names(data_pca2)
colnames(data_pca2)[2]<-"Sharpes"
CV_pca1<-cor(data_pca2$CV, data_pca2$pc1,method= "spearman")
CV_pca2<-cor(data_pca2$CV, data_pca2$pc2, method= "spearman")
CV_pca3<-cor(data_pca2$CV, data_pca2$pc3, method= "spearman")
sharpes_pca1<-cor(data_pca2$Sharpes, data_pca2$pc1, method= "spearman")
sharpes_pca2<-cor(data_pca2$Sharpes, data_pca2$pc2, method= "spearman")
sharpes_pca3<-cor(data_pca2$Sharpes, data_pca2$pc3, method= "spearman")
digits=2
labels<-c( "PC1", "PC2","PC3")
results1<-c(CV_pca1, CV_pca2,CV_pca3)
results2<-c(sharpes_pca1, sharpes_pca2, sharpes_pca3)
results3<-cbind(labels, results1, results2)
out_table<-kable(results3, digits=getOption("digits"), col.names=c("Principal component","CV", "Sharpe's"))
out_table
sort(abs(pca_test$rotation[,1]))
sort(abs(pca_test$rotation[,2]))
sort(abs(pca_test$rotation[,3]))
plot(Sharpes~pc1, data=data_pca2, xlab=c("PC1"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc1, data=data_pca2, xlab=c("PC1"), ylab=c("CV"))
plot(Sharpes~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("CV"))
plot(Sharpes~pc3, data=data_pca2, xlab=c("PC3"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc3, data=data_pca2, xlab=c("PC3"), ylab=c("CV"))
data4_scale<-scale(data4)
data4_scale_pop<-as.data.frame(cbind(CohoDataSummary$Population,data4_scale))
colnames(data4_scale_pop)[1]<-"population"
data4_scale_pop_2<-merge(OC_COHO_SharpeRatio_CV, data4_scale_pop, by.x="Population", by.y="population")
indx <- sapply(data4_scale_pop_2, is.factor)
data4_scale_pop_2[indx] <- lapply(data4_scale_pop_2[indx], function(x) as.numeric(as.character(x)))
m1<-lm(CV~MeanCanopy_p+Lake_sqkm+Latitude, data=data4_scale_pop_2)
names(data4_scale_pop_2)
fit <- lm(CV~MeanCanopy_p+HighIP_m+Sedimentary_p+Estuary_sqkm+Lake_sqkm+Public_p+Latitude+Agric_p,data=data4_scale_pop_2)
step <- stepAIC(fit, direction="both")
step$anova
fit <- lm(Sharps~MeanCanopy_p+HighIP_m+Sedimentary_p+Estuary_sqkm+Lake_sqkm+Public_p+Latitude+Agric_p,data=data4_scale_pop_2)
names(data4_scale_pop_2)
colnames(data4_scale_pop)[2]<-"Sharpes"
fit <- lm(Sharpes~MeanCanopy_p+HighIP_m+Sedimentary_p+Estuary_sqkm+Lake_sqkm+Public_p+Latitude+Agric_p,data=data4_scale_pop_2)
names(data4_scale_pop_2)
colnames(data4_scale_pop)[2]<-"Sharpes"
data4_scale_pop_2<-merge(OC_COHO_SharpeRatio_CV, data4_scale_pop, by.x="Population", by.y="population")
names(data4_scale_pop_2)
names(data4_scale_pop)
names(data4_scale_pop_2)
names(data4_scale_pop_2)
colnames(data4_scale_pop_2)[2]<-"Sharpes"
fit <- lm(Sharpes~MeanCanopy_p+HighIP_m+Sedimentary_p+Estuary_sqkm+Lake_sqkm+Public_p+Latitude+Agric_p,data=data4_scale_pop_2)
data4
data4
data4_scale_pop<-as.data.frame(cbind(CohoDataSummary$Population,data4_scale))
data4_scale_pop
data4_scale_pop_2<-merge(OC_COHO_SharpeRatio_CV, data4_scale_pop, by.x="Population", by.y="population")
data4_scale<-scale(data4)
data4_scale_pop<-as.data.frame(cbind(CohoDataSummary$Population,data4_scale))
OC_COHO_SharpeRatio_CV <- read_csv("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/OC_COHO_SharpeRatio_CV.csv")
CohoDataSummary <- read_csv("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Matt's Work/Data/Spreadsheets/CohoDataSummary.csv")
#summary(CohoDataSummary)
data1<-CohoDataSummary[,-1]
data2<-data1[,-1]
#names(data2)
#class(data2)
#pairs(data2)
cor_out<-cor(data2, method="spearman")
write.csv(cor_out, "L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/watershed_correlations.csv")
plot(data2$MeanAnnualPrecip_mm, data2$Latitude)
plot(data2$MeanAugtemps_c, data2$Latitude)
plot(data2$MeanAugtemps_c, data2$MeanAnnualPrecip_mm)
plot(data2$TotalLength_m, data2$HighIP_m)
# data3 <- select(data2, HighCritHab_p,
#                 MeanElev_m,
#                 MeanAnnualPrecip_mm,
#                 MeanBFI,
#                 Watershed_sqkm,
#                 Sedimentary_p,
#                 HighIP_p,
#                 Estuary_sqkm,
#                 Lake_p,
#                 MeanHFI,
#                 Latitude,
#                 SplashCount)
# create subset from spreadsheet
watershed_correlations_plus_selection <- read_csv("L:/Priv/CORFiles/Projects/ACE_CIVA_2.8/Marcia/Data/Portfolio_metrics/watershed_correlations_plus_selection.csv")
vars<-watershed_correlations_plus_selection[ which(watershed_correlations_plus_selection$Include=="Y"),]
vars2<-unique(vars$Attribute)
vars2
# data3<-select(data2,
#               MeanCanopy_p,
#               HighIP_m,
#               Sedimentary_p,
#               Estuary_sqkm,
#               Lake_sqkm,
#               Public_p,
#               Latitude,
#               Agric_p)
keep<-c(6, 13, 16, 18, 19, 24, 26, 28 )
data3<-data2[, keep ]
pairs(data3)
cor(data3, method="spearman")
data4<-log(data3+1)
#dim(data4)
data4_scale<-scale(data4)
data4_scale
data4_scale_pop<-as.data.frame(cbind(CohoDataSummary$Population,data4_scale))
data4_scale_pop
colnames(data4_scale_pop)[1]<-"population"
data4_scale_pop
data4_scale_pop_2<-merge(OC_COHO_SharpeRatio_CV, data4_scale_pop, by.x="Population", by.y="population")
data4_scale_pop_2
colnames(data4_scale_pop_2)[2]<-"Sharpes"
data4_scale_pop_2
indx <- sapply(data4_scale_pop_2, is.factor)
data4_scale_pop_2[indx] <- lapply(data4_scale_pop_2[indx], function(x) as.numeric(as.character(x)))
summary(data4_scale_pop_2)
fit <- lm(CV~MeanCanopy_p+HighIP_m+Sedimentary_p+Estuary_sqkm+Lake_sqkm+Public_p+Latitude+Agric_p,data=data4_scale_pop_2)
step <- stepAIC(fit, direction="both")
step$anova
fit <- lm(Sharpes~MeanCanopy_p+HighIP_m+Sedimentary_p+Estuary_sqkm+Lake_sqkm+Public_p+Latitude+Agric_p,data=data4_scale_pop_2)
step <- stepAIC(fit, direction="both")
step$anova
library(relaimpo)
install.packages("relaimpo")
calc.relimp(fit,type=c("MeanCanopy_p", "HighIP_m","Sedimentary_p","Estuary_sqkm","Lake_sqkm","Public_p","Latitude","Agric_p"),
rela=TRUE)
library(relaimpo)
calc.relimp(fit,type=c("MeanCanopy_p", "HighIP_m","Sedimentary_p","Estuary_sqkm","Lake_sqkm","Public_p","Latitude","Agric_p"),
rela=TRUE)
fit
calc.relimp(fit,type=c("MeanCanopy_p","HighIP_m","Sedimentary_p","Estuary_sqkm","Lake_sqkm","Public_p","Latitude","Agric_p"),rela=TRUE)
?calc.relimp
calc.relimp(fit,type=c("lmg","last","first","pratt"),rela=TRUE)
boot <- boot.relimp(fit, b = 1000, type = c("lmg",
"last", "first", "pratt"), rank = TRUE,
diff = TRUE, rela = TRUE)
booteval.relimp(boot) # print result
plot(booteval.relimp(boot,sort=TRUE)) # plot result
calc.relimp(fit,type=c("lmg","last","first","pratt"),rela=TRUE)
# drop estuary km2
data4<-data4[,-4]
#names(data4)
# pca
pca_test2<-prcomp(data4, scale=TRUE)
# look at signficance of eigen value compared to broken stick expected value by random
pca.eigenval(pca_test2)
screeplot(pca_test2)
pca.eigenvec(pca_test2,dim=3,digits=3,cutoff=.1)
# structure coefficients
pca.structure(pca_test2,data4,dim=3,cutoff=.4)
# variance accounted for in total by retained principal components by adding up all squared structure coefficients of retained principal components
pca.communality(pca_test2,data4,dim=3)
biplot(pca_test2)
# grab principal component scores for significant components
pc1<-pca_test2$x[1:21,1]
pc2<-pca_test2$x[1:21,2]
pc3<-pca_test2$x[1:21,3]
#class(pc1)
data_pca<-cbind(CohoDataSummary$Population,data4,pc1, pc2, pc3)
colnames(data_pca)[1]<-"population"
#View(OC_COHO_SharpeRatio_CV)
data_pca2<-merge(OC_COHO_SharpeRatio_CV, data_pca, by.x="Population", by.y="population")
#names(data_pca2)
colnames(data_pca2)[2]<-"Sharpes"
CV_pca1<-cor(data_pca2$CV, data_pca2$pc1,method= "spearman")
CV_pca2<-cor(data_pca2$CV, data_pca2$pc2, method= "spearman")
CV_pca3<-cor(data_pca2$CV, data_pca2$pc3, method= "spearman")
sharpes_pca1<-cor(data_pca2$Sharpes, data_pca2$pc1, method= "spearman")
sharpes_pca2<-cor(data_pca2$Sharpes, data_pca2$pc2, method= "spearman")
sharpes_pca3<-cor(data_pca2$Sharpes, data_pca2$pc3, method= "spearman")
digits=2
labels<-c( "PC1", "PC2","PC3")
results1<-c(CV_pca1, CV_pca2,CV_pca3)
results2<-c(sharpes_pca1, sharpes_pca2, sharpes_pca3)
results3<-cbind(labels, results1, results2)
out_table<-kable(results3, digits=getOption("digits"), col.names=c("Principal component","CV", "Sharpe's"))
out_table
sort(abs(pca_test2$rotation[,1]))
sort(abs(pca_test2$rotation[,2]))
sort(abs(pca_test2$rotation[,3]))
plot(Sharpes~pc1, data=data_pca2, xlab=c("PC1"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc1, data=data_pca2, xlab=c("PC1"), ylab=c("CV"))
```{r PC2 plots2, echo=FALSE}
plot(Sharpes~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("CV"))
plot(Sharpes~pc3, data=data_pca2, xlab=c("PC3"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc3, data=data_pca2, xlab=c("PC3"), ylab=c("CV"))
data_all<-log(data2+1)
dim(data_all)
names(data_all)
for_keep<-c(1,4,6,7,8,9,10,12,13,15,16,18,19,22,23,25,26,27,28)
data_all<-data_all[,for_keep]
dim(data_all)
head(data.frame(data_all))
pca_all<-prcomp(data_all, scale=TRUE)
pca_all
screeplot(pca_all)
biplot(pca_all)
sort(abs(pca_all$rotation[,1]))
sort(abs(pca_all$rotation[,2]))
sort(abs(pca_all$rotation[,3]))
pca.eigenval(pca_all)
pca.eigenvec(pca_all,dim=3,digits=3,cutoff=.2)
pca.structure(pca_all,data_all,dim=3,cutoff=.2)
pca.communality(pca_all,data_all,dim=3)
pc1<-pca_all$x[1:21,1]
pc2<-pca_all$x[1:21,2]
pc3<-pca_all$x[1:21,3]
data_pca<-cbind(CohoDataSummary$Population,data_all,pc1, pc2, pc3)
colnames(data_pca)[1]<-"population"
data_pca2<-merge(OC_COHO_SharpeRatio_CV, data_pca, by.x="Population", by.y="population")
colnames(data_pca2)[2]<-"Sharpes"
CV_pca1<-cor(data_pca2$CV, data_pca2$pc1,method= "spearman")
CV_pca2<-cor(data_pca2$CV, data_pca2$pc2, method= "spearman")
CV_pca3<-cor(data_pca2$CV, data_pca2$pc3, method= "spearman")
sharpes_pca1<-cor(data_pca2$Sharpes, data_pca2$pc1, method= "spearman")
sharpes_pca2<-cor(data_pca2$Sharpes, data_pca2$pc2, method= "spearman")
sharpes_pca3<-cor(data_pca2$Sharpes, data_pca2$pc3, method= "spearman")
digits=2
labels<-c( "PC1", "PC2","PC3")
results1<-c(CV_pca1, CV_pca2,CV_pca3)
results2<-c(sharpes_pca1, sharpes_pca2, sharpes_pca3)
results3<-cbind(labels, results1, results2)
out_table<-kable(results3, digits=getOption("digits"), col.names=c("Principal component","CV", "Sharpe's"))
out_table
sort(abs(pca_test2$rotation[,2]))
sort(abs(pca_all$rotation[,2]))
sort(abs(pca_all$rotation[,3]))
plot(Sharpes~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("Sharpe's ratio (leave one out)"))
plot(CV~pc2, data=data_pca2, xlab=c("PC2"), ylab=c("CV"))
